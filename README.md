Vector

    Ограничение времени	20 секунд
    Ограничение памяти	128.0 Мб
    Ввод	стандартный ввод или input.txt
    Вывод	стандартный вывод или output.txt


Vector

Ранее в курсе был рассмотрен класс динамической строки std::string, которая увеличивает размер массива символов по мере необходимости и самостоятельно управляет выделяемой памятью. В этом задании мы рассмотрим класс std::vector, являющийся обобщением динамической строки на произвольный тип, то есть класс динамического массива.

std::vector

Интерфейс и реализация std::vector<T> во многом похожи на std::string. Ключевым отличием является семантика работы метода reserve (и остальных методов, которые приводят к увеличению capacity). При резервировании памяти под большее число объектов, выделяется "сырая" (неинициализированная) память достаточная для хранения нужного числа дополнительных объектов. Пустые ячейки заполняются лениво по мере необходимости. То есть, если size < capacity, то это значит, что первые size * sizeof(T) байт реально заняты объектами, а последние (capacity - size) * sizeof(T) байт пусты - объектов там не создано. Это нужно, например, для того, чтобы можно было создавать вектор из объектов, у которых нет конструктора по умолчанию (а как бы тогда нужно было инициализировать неиспользуемые ячейки?):

struct A {
  int x;

  A() = delete;
  explicit A(int x_param) : x(x_param) {
  }
};

std::vector<A> v;
v.reserve(1000);  // объекты A не создаются! Выделяется "сырая" память размера 1000 * sizeof(A)
for (int i = 0; i < 1000; ++i) {
  v.push_back(A(i));
  // а лучше v.emplace_back(i);
}

Детали реализации

От вас требуется реализовать шаблонный класс Vector с единственным шаблонным параметром - типом хранящихся элементов. При реализации можно (и даже нужно) пользоваться обобщенными алгоритмами из STL (std::copy, std::fill и т.п.), но нельзя использовать стандартные контейнеры. Будет проверяться корректность мультипликативной схемы расширения массива с коэффициентом 2. В базовой версии ручное управление временем жизни объектов не требуется (см. доп. задание). Класс должен поддерживать следующий функционал:


Конструктор по умолчанию - создает пустой массив;

Явный конструктор от числа - создает массив заданного размера заполненный объектами, сконструированными по умолчанию;

Конструктор, принимающий size и value (именно в этом порядке) - создает массив длины size, заполненный элементами со значением value;

Шаблонный конструктор, принимающий пару итераторов - создает копию переданного диапазона;

Важно: объявление этого конструктора должно иметь вид

template <class Iterator, class = std::enable_if_t<std::is_base_of_v<std::forward_iterator_tag, typename std::iterator_traits<Iterator>::iterator_category>>>

Vector(Iterator first, Iterator last)

Это делает конструктор доступным только в случае, когда на вход приходят два Forward итератора.

Конструктор от std::initializer_list;

Правило "пяти";

Методы Size, Capacity, Empty;

Константный и неконстантный оператор доступа по индексу []. Неконстантный должен позволять изменять полученный элемент;

Константный и неконстантный метод доступа по индексу At. При выходе за границы массива должен бросать исключение std::out_of_range;

Методы Front() и Back()

доступ к первому и последнему элементам (тоже по две версии).

Метод Data()

возвращает указатель на начало массива.

Метод Swap(other)

обменивает содержимое с другим массивом other;

Метод Resize(new_size)

изменяет размер на new_size. Если вместимость не позволяет хранить столько элементов, то выделяется новый буфер с вместимостью new_size. Недостающие элементы конструируются по умолчанию.

Метод Resize(new_size, value)

то же, что и Resize(new_size), но в случае new_size > size заполняет недостающие элементы значением value.

Метод Reserve(new_cap)

изменяет вместимость на max(new_cap, текущая вместимость). Размер при этом не изменяется.

Метод ShrinkToFit()

уменьшает capacity до size.

Метод Clear()

устанавливает размер в 0, очищения выделенной памяти при этом НЕ происходит.

Методы PushBack(const T&) и PushBack(T&&)

добавляет новый элемент в конец массива.

Метод PopBack()

удаляет последний элемент.

Операции сравнения (<, >, <=, >=, ==, !=), задающие лексикографический порядок.

Также реализуйте поддержку итераторов и методы для работы с ними: begin(), end(), cbegin(), cend(), rbegin(), rend(), crbegin(), crend(). begin()-end(), rbegin()-rend() должны иметь две версии, возвращающие константные и неконстантные итераторы. Для того, чтобы codestyle не ругался на написание методов с маленькой буквы, напишите в данной строке комментарий // NOLINT

Внутри класса Vector определите типы-члены ValueType, Pointer, ConstPointer, Reference, ConstReference, SizeType, Iterator, ConstIterator.

Гарантии безопасности

Спроектируйте класс так, чтобы при возникновении исключений (нехватка памяти, ошибка при копировании объектов и т.п.) методы удовлетворяли строгой гарантии безопасности. То есть все методы должны работать атомарно: либо работать без сбоев, либо не изменять исходного состояния вектора. Исключение: копирующее присваивание может давать лишь базовую гарантию безопасности.

При решении можно предполагать, что конструкторы перемещения, перемещающие присваивания и деструкторы объектов никогда не бросают исключений!

Vector+

    Ограничение времени	20 секунд
    Ограничение памяти	128.0 Мб
    Ввод	стандартный ввод или input.txt
    Вывод	стандартный вывод или output.txt

Дополнительная часть к задаче Vector (работа с памятью)

Реализуйте полноценное управление памятью, описанное во второй секции основного задания. То есть в каждый момент времени должно существовать ровно size объектов. При добавлении элементов (например, с помощью PushBack, либо Resize) новые элементы должны создаваться вручную с помощью placement new, а при удалении элемента (например, с помощью PopBack или Clear) для него вручную должен вызываться деструктор (либо std::destroy и std::destroy_at).

При решении можно использовать алгоритмы стандартной библиотеки для работы с неинициализированной памятью (секция uninitialized storage). Они значительно упростят работу.
